"use strict";(self.webpackChunktest=self.webpackChunktest||[]).push([[302],{7551:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>l});var a=r(4848),n=r(8453);const s={title:"Jaeger",sidebar_position:1},i="Traces Tools: Jaeger",c={id:"available-toolkit/traces/jaeger",title:"Jaeger",description:"Within the Observability Stack, Jaeger plays an intermediary role in trace data collection. It leverages the Jaeger operator available on OperatorHub.io. The setup involves configuring the OpenTelemetry Collector (deployed in a daemonset mode) to forward OTLP trace data directly to the Jaeger collector. The Jaeger collector then utilizes the centralized Opensearch cluster as its backend storage for these traces, enabling seamless integration with the available Observability Stack toolkit. For detailed insights, refer to the logs section.",source:"@site/docs/available-toolkit/traces/jaeger.md",sourceDirName:"available-toolkit/traces",slug:"/available-toolkit/traces/jaeger",permalink:"/available-toolkit/traces/jaeger",draft:!1,unlisted:!1,editUrl:"https://github.com/observability-stack/observability-stack.io/edit/main/docs/docs/available-toolkit/traces/jaeger.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Jaeger",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Traces",permalink:"/category/traces"},next:{title:"OpenTelemetry",permalink:"/available-toolkit/traces/opentelemetry"}},o={},l=[{value:"Architecture",id:"architecture",level:2},{value:"Quickstart",id:"quickstart",level:2},{value:"Advanced Configuration",id:"advanced-configuration",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",p:"p",pre:"pre",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"traces-tools-jaeger",children:"Traces Tools: Jaeger"})}),"\n",(0,a.jsxs)(t.p,{children:["Within the Observability Stack, Jaeger plays an intermediary role in trace data collection. It leverages the Jaeger operator available on ",(0,a.jsx)(t.a,{href:"https://operatorhub.io/operator/jaeger",children:"OperatorHub.io"}),". The setup involves configuring the OpenTelemetry Collector (deployed in a daemonset mode) to forward OTLP trace data directly to the Jaeger collector. The Jaeger collector then utilizes the centralized Opensearch cluster as its backend storage for these traces, enabling seamless integration with the available Observability Stack toolkit. For detailed insights, refer to the ",(0,a.jsx)(t.a,{href:"./logs",children:"logs section"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["This architecture enables Grafana to utilize Jaeger as a datasource, enhancing visualization capabilities by showcasing traces with logs and metrics. Additionally, Jaeger undertakes the management of Opensearch indices lifecycle through the ",(0,a.jsx)(t.code,{children:"jaeger-tracing-es-index-cleaner"}),", ensuring efficient storage handling."]}),"\n",(0,a.jsxs)(t.p,{children:["The Observability Stack deploys the Jaeger collector across both ",(0,a.jsx)(t.code,{children:"observer"})," and ",(0,a.jsx)(t.code,{children:"observee"})," clusters. However, Jeager deployment in the ",(0,a.jsx)(t.code,{children:"observer"})," cluster can use the internal service discovery for accessing the central Opensearch cluster, while Jeager deployments on ",(0,a.jsx)(t.code,{children:"observee"})," clusters might require an external URL (e.g., ingress) to access the Opensearch APIs. Therefore, a special configuration might be needed according to the requirements of centralized data processing and storage."]}),"\n",(0,a.jsxs)(t.p,{children:["This differentiation in configuration is achieved through the use of Kustomize overlays, specifically the ",(0,a.jsx)(t.code,{children:"overlays/observer-cluster"}),", which is referenced in the Fleet deployment strategy."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:"targetCustomizations:\n  - name: observer-cluster\n    clusterName: observer-cluster\n    kustomize:\n      dir: overlays/observer-cluster\n"})}),"\n",(0,a.jsx)(t.h2,{id:"architecture",children:"Architecture"}),"\n",(0,a.jsx)("div",{style:{textAlign:"center"},children:(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Jeager Multi-cluster Architecture",src:r(2110).A+"",width:"1259",height:"622"})})}),"\n",(0,a.jsx)(t.h2,{id:"quickstart",children:"Quickstart"}),"\n",(0,a.jsxs)(t.p,{children:['The Observability Stack recommends creating a Kubernetes secret named "opensearch-admin-credential" for Jeager - Opensearch API connection details. This secret should then be mounted using the ',(0,a.jsx)(t.code,{children:"spec.secretName"})," field in the Jeager cluster values."]}),"\n",(0,a.jsx)(t.p,{children:"The S3 connection YAML manifest should follow this format:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Secret\nmetadata:\n  name: opensearch-admin-credential\n  namespace: tracing-system\ntype: Opaque\ndata:\n  username: b3BlbnNlYXJjaC1hZG1pbg== #base64\n  password: cGxlYXNlRG9udFVzZVRoaXM= #base64\n"})}),"\n",(0,a.jsx)(t.p,{children:"To create this secret via kubectl, use the following command, ensuring your YAML manifest is saved to a file (e.g., opensearch-admin-credential.yaml:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"kubectl create secret generic opensearch-admin-credential -f opensearch-admin-credential.yaml\n"})}),"\n",(0,a.jsx)(t.p,{children:"For external access to the Opensearch APIs from observee clusters\u2014particularly in scenarios where internal cross-cluster communication isn't available\u2014it's necessary to specify the external URL in the jaeger.yaml manifest. This configuration file is located under the cluster/base directory. Here's how you can define it;"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:"spec:\n  storage:\n    type: elasticsearch\n    options:\n      es.server-urls: https://<opensearch-api-externalURL>\n"})}),"\n",(0,a.jsx)(t.h2,{id:"advanced-configuration",children:"Advanced Configuration"}),"\n",(0,a.jsxs)(t.p,{children:["For an automated setup, the secret should be integrated into the ",(0,a.jsx)(t.code,{children:"cluster/base"})," directory alongside with Jaeger components. A corresponding ",(0,a.jsx)(t.code,{children:"kustomization.yaml"})," file ensures automatic creation of the secret. This setup supports both regular Kubernetes secrets (without encryption) and more secure approaches like integrating with ",(0,a.jsx)(t.a,{href:"https://www.vaultproject.io/",children:"HashiCorp Vault"}),", utilizing the ",(0,a.jsx)(t.a,{href:"https://external-secrets.io/latest/",children:"external-secrets-operator"})," to import the secret as an ExternalSecret object."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:"apiVersion: external-secrets.io/v1beta1\nkind: ExternalSecret\nmetadata:\n  name: opensearch-admin-credential\nspec:\n  dataFrom:\n    - extract:\n        key: tracing/opensearch-admin-credential\n  refreshInterval: 1h\n  secretStoreRef:\n    kind: ClusterSecretStore\n    name: hashicorp-vault-backend\n  target:\n    creationPolicy: Owner\n    deletionPolicy: Retain\n    name: opensearch-admin-credential\n"})})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},2110:(e,t,r)=>{r.d(t,{A:()=>a});const a=r.p+"assets/images/traces-architecture-a089fd2008056306e30c9e29df2e6183.png"},8453:(e,t,r)=>{r.d(t,{R:()=>i,x:()=>c});var a=r(6540);const n={},s=a.createContext(n);function i(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);